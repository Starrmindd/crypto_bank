<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Working Decryption Example</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
        .example { background: #f0f8ff; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .code { background: #f5f5f5; padding: 15px; border-radius: 5px; font-family: monospace; white-space: pre-wrap; }
        .button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 10px 5px; }
        .button:hover { background: #0056b3; }
        .result { background: #d4edda; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .error { background: #f8d7da; padding: 15px; border-radius: 5px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Working Decryption Example</h1>
    
    <div class="example">
        <h3>Step 1: Generate Test Data</h3>
        <button class="button" onclick="generateAndTest()">Generate & Test Encryption/Decryption</button>
        <div id="testResult"></div>
    </div>

    <div class="example">
        <h3>Step 2: Use in Decryption Form</h3>
        <p>After generating test data above, copy the values to your decryption form:</p>
        <div id="copyableData"></div>
        <button class="button" onclick="window.open('decrypt.html', '_blank')">Open Decryption Form</button>
    </div>

    <script>
        let testData = {};

        async function generateAndTest() {
            const resultDiv = document.getElementById('testResult');
            const copyDiv = document.getElementById('copyableData');
            
            try {
                resultDiv.innerHTML = '<p>Generating test data...</p>';
                
                // Generate test keys
                const privateKey = '0x' + Array.from(crypto.getRandomValues(new Uint8Array(32)))
                    .map(b => b.toString(16).padStart(2, '0')).join('');
                
                const publicKey = '0x' + Array.from(crypto.getRandomValues(new Uint8Array(64)))
                    .map(b => b.toString(16).padStart(2, '0')).join('');
                
                const seedSecret = '0x' + Array.from(crypto.getRandomValues(new Uint8Array(32)))
                    .map(b => b.toString(16).padStart(2, '0')).join('');

                const message = "Hello! This is a test message for Chaotic ECC decryption.";
                const metadata = {
                    timestamp: new Date().toISOString(),
                    type: "test_message",
                    sender: "alice",
                    recipient: "bob"
                };

                // Encrypt the message
                const encryptedData = await encryptMessage(privateKey, publicKey, message, metadata, seedSecret);
                
                // Test decryption
                const decryptedMessage = await decryptMessage(privateKey, publicKey, encryptedData);
                
                // Store test data
                testData = {
                    privateKey,
                    publicKey,
                    seedSecret,
                    encryptedData,
                    originalMessage: message,
                    decryptedMessage
                };

                // Display results
                if (decryptedMessage === message) {
                    resultDiv.innerHTML = `
                        <div class="result">
                            <h4>✅ Success! Encryption/Decryption Test Passed</h4>
                            <p><strong>Original:</strong> "${message}"</p>
                            <p><strong>Decrypted:</strong> "${decryptedMessage}"</p>
                        </div>
                    `;
                    
                    copyDiv.innerHTML = `
                        <h4>Copy these values to the decryption form:</h4>
                        <p><strong>Private Key:</strong></p>
                        <div class="code">${privateKey}</div>
                        <p><strong>Sender's Public Key:</strong></p>
                        <div class="code">${publicKey}</div>
                        <p><strong>Encrypted Data (JSON):</strong></p>
                        <div class="code">${JSON.stringify(encryptedData, null, 2)}</div>
                        <p><strong>Seed Secret:</strong></p>
                        <div class="code">${seedSecret}</div>
                        <button class="button" onclick="copyAllData()">Copy All Data</button>
                    `;
                } else {
                    resultDiv.innerHTML = `
                        <div class="error">
                            <h4>❌ Test Failed</h4>
                            <p>Decryption did not match original message</p>
                        </div>
                    `;
                }

            } catch (error) {
                resultDiv.innerHTML = `
                    <div class="error">
                        <h4>❌ Error</h4>
                        <p>${error.message}</p>
                    </div>
                `;
                console.error('Test error:', error);
            }
        }

        async function encryptMessage(privateKeyHex, publicKeyHex, message, metadata, seedSecret) {
            // Derive shared key
            const sharedKey = await deriveSharedKey(privateKeyHex, publicKeyHex);
            
            // Convert message to buffer
            const messageBuffer = new TextEncoder().encode(message);
            
            // Prepare AAD
            const aad = new TextEncoder().encode(JSON.stringify(metadata));
            
            // Encrypt
            const result = await aesGcmEncrypt(sharedKey, messageBuffer, aad);
            
            // Generate chaotic fingerprint
            const fingerprint = await generateChaoticFingerprint(metadata, seedSecret);
            
            return {
                iv: result.iv,
                ct: result.ct,
                tag: result.tag,
                metadata: metadata,
                aad: bufferToHex(aad),
                timestamp: new Date().toISOString(),
                chaoticFingerprint: fingerprint
            };
        }

        async function decryptMessage(privateKeyHex, publicKeyHex, encryptedData) {
            // Derive shared key
            const sharedKey = await deriveSharedKey(privateKeyHex, publicKeyHex);
            
            // Decrypt
            const decryptedBuffer = await aesGcmDecrypt(
                sharedKey,
                encryptedData.iv,
                encryptedData.ct,
                encryptedData.tag,
                hexToBuffer(encryptedData.aad)
            );
            
            return new TextDecoder().decode(decryptedBuffer);
        }

        async function deriveSharedKey(privateKeyHex, publicKeyHex) {
            const privateKey = privateKeyHex.replace(/^0x/, '');
            const publicKey = publicKeyHex.replace(/^0x/, '');
            const combined = privateKey + publicKey;
            const encoder = new TextEncoder();
            const data = encoder.encode(combined);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            
            return await crypto.subtle.importKey(
                'raw',
                hashBuffer,
                { name: 'AES-GCM' },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async function aesGcmEncrypt(key, plaintextBuffer, aad = null) {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            const encryptParams = {
                name: 'AES-GCM',
                iv: iv
            };

            if (aad && aad.length > 0) {
                encryptParams.additionalData = aad;
            }
            
            const encryptedBuffer = await crypto.subtle.encrypt(
                encryptParams,
                key,
                plaintextBuffer
            );

            const encrypted = new Uint8Array(encryptedBuffer);
            const ciphertext = encrypted.slice(0, -16);
            const tag = encrypted.slice(-16);

            return {
                iv: bufferToHex(iv),
                ct: bufferToHex(ciphertext),
                tag: bufferToHex(tag)
            };
        }

        async function aesGcmDecrypt(key, ivHex, ctHex, tagHex, aad = null) {
            const iv = hexToBuffer(ivHex);
            const ciphertext = hexToBuffer(ctHex);
            const tag = hexToBuffer(tagHex);
            
            const encryptedData = new Uint8Array(ciphertext.length + tag.length);
            encryptedData.set(ciphertext, 0);
            encryptedData.set(tag, ciphertext.length);

            const decryptParams = {
                name: 'AES-GCM',
                iv: iv
            };

            if (aad && aad.length > 0) {
                decryptParams.additionalData = aad;
            }

            const decrypted = await crypto.subtle.decrypt(
                decryptParams,
                key,
                encryptedData
            );

            return new Uint8Array(decrypted);
        }

        async function generateChaoticFingerprint(metadataJson, seedSecretHex) {
            const encoder = new TextEncoder();
            const metadataStr = JSON.stringify(metadataJson);
            const seedBuffer = hexToBuffer(seedSecretHex.replace(/^0x/, ''));
            
            const hashBuffer = await crypto.subtle.digest('SHA-256', 
                new Uint8Array([...encoder.encode(metadataStr), ...seedBuffer])
            );
            
            const x0 = seedToUnit(new Uint8Array(hashBuffer));
            const sequence = logisticIteration(x0, 3.99, 16);
            const quantized = quantizeSequence(sequence);
            
            const finalHashBuffer = await crypto.subtle.digest('SHA-256', 
                new Uint8Array([...quantized, ...encoder.encode(metadataStr)])
            );
            
            return bufferToHex(new Uint8Array(finalHashBuffer));
        }

        function seedToUnit(seedBuffer) {
            let value = 0;
            for (let i = 0; i < Math.min(8, seedBuffer.length); i++) {
                value = value * 256 + seedBuffer[i];
            }
            return (value % 1000000000000) / 1000000000000;
        }

        function logisticIteration(x0, r = 3.99, k = 16) {
            let x = x0;
            const sequence = [];
            for (let i = 0; i < k; i++) {
                x = r * x * (1 - x);
                sequence.push(x);
            }
            return sequence;
        }

        function quantizeSequence(sequence) {
            const result = new Uint8Array(sequence.length * 4);
            let offset = 0;
            
            for (const x of sequence) {
                const val = Math.floor(x * (2 ** 32)) >>> 0;
                result[offset++] = (val >>> 24) & 0xFF;
                result[offset++] = (val >>> 16) & 0xFF;
                result[offset++] = (val >>> 8) & 0xFF;
                result[offset++] = val & 0xFF;
            }
            
            return result;
        }

        function hexToBuffer(hex) {
            const cleanHex = hex.replace(/^0x/, '');
            const bytes = new Uint8Array(cleanHex.length / 2);
            for (let i = 0; i < cleanHex.length; i += 2) {
                bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
            }
            return bytes;
        }

        function bufferToHex(buffer) {
            return Array.from(buffer)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        function copyAllData() {
            const data = `Private Key: ${testData.privateKey}

Sender's Public Key: ${testData.publicKey}

Encrypted Data (JSON):
${JSON.stringify(testData.encryptedData, null, 2)}

Seed Secret: ${testData.seedSecret}`;

            navigator.clipboard.writeText(data).then(() => {
                alert('All data copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy to clipboard');
            });
        }
    </script>
</body>
</html>